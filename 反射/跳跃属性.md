

## 案例1
有同学把 引擎里面的 一个 private 属性改成了 public.
然后没有重新打包成SO库，游戏也可以 继续下去，而没有报错，

也就是说 SO库里的那个 属性应该是 private，但是居然可以 访问那个属性。

## 实验1
然后怀疑是 打包SO库的时候，没有 打包那个C++文件。
于是在那个 改属性的 那个C++文件 里面，打了几个汉字-非注释。

然后再打包SO库，直接报错，说有非法字符。
证明 打包SO库的时候，确实 把 那个文件包含进去了。


## 猜测1
是不是打包成SO库的时候， 把所有方法 和 属性 都变成 public 的了。

有待验证。


## public 只是编译的时候，编译器防止你访问的。
编译成功后的代码，那你其实是可以随便访问的。


## 实验2

在一个工程里面，把一个成员 改成private.
然后进行 ant编译，直接报 private  权限  出错。

## 猜测2
在C++打包成SO库的时候，会对调用自身的函数 进行检测 权限问题。

但是当C++打包时，调用的是别的SO库的函数，则不进行检查 调用的那个函数的权限问题...。