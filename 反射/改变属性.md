

## 案例1
有同学把 引擎里面的 一个 private 属性改成了 public.
然后没有重新打包成SO库，游戏也可以 继续下去，而没有报错，

也就是说 SO库里的那个 属性应该是 private，但是居然可以 访问那个属性。

## 实验1
然后怀疑是 打包SO库的时候，没有 打包那个C++文件。
于是在那个 改属性的 那个C++文件 里面，打了几个汉字-非注释。

然后再打包SO库，直接报错，说有非法字符。
证明 打包SO库的时候，确实 把 那个文件包含进去了。


## 猜测1
是不是打包成SO库的时候， 把所有方法 和 属性 都变成 public 的了。

有待验证。


## public 只是编译的时候，编译器防止你访问的。
编译成功后的代码，那你其实是可以随便访问的。


## 实验2

在一个工程里面，把一个成员 改成private.
然后进行 ant编译，直接报 private  权限  出错。

## 猜测2
在C++打包成SO库的时候，会对调用自身的函数 进行检测 权限问题。

但是当C++打包时，调用的是别的SO库的函数，则不进行检查 调用的那个函数的权限问题...。


## 实验3
找了个工程，调用了SO库里的一个函数。 这个SO库生成时，那个函数的头文件【CCArmatureDataManager.h】写的 private
然后 ant 编译这个工程的时候，引用的头文件【CCArmatureDataManager.h】写的是这个函数 是 public 。
编译可以通过。

然后 我在 【CCArmatureDataManager.h】 里加了几个 汉字字符，ant 编译该工程文件就 编译不过去了。
说明 ant 编译时，确实 引用了该头文件。
然后 修改 【CCArmatureDataManager.h】 里那个 函数的属性为 private ，也不通过了。
改成 public ，就可以通过了。

## 推测3

编译SO库的时候，没有把 头文件包含进去，所以编译一个工程，这个工程包含了该SO的时候，提供的头文件 可以自己随便 修改属性。